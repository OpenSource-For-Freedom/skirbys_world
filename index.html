<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skirbys World</title>
    <!-- Tailwind CSS for modern styling and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #87CEEB; /* Sky blue background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            color: #333;
        }

        #game-container {
            background-color: #A0D2EB; /* Lighter blue for game area */
            border-radius: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2), 0 0 0 10px rgba(255, 255, 255, 0.3); /* Outer glow for Lego feel */
            overflow: hidden;
            position: relative;
            width: 90vw; /* Responsive width */
            max-width: 1200px; /* Max width for larger screens */
            aspect-ratio: 16 / 9; /* Maintain aspect ratio */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #BEE3F8; /* Even lighter blue for canvas background */
            display: block;
            border-radius: 15px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.1); /* Inner shadow for depth */
            width: 100%; /* Canvas fills its container */
            height: 100%;
        }

        #intro-menu, #game-ui, #game-over-ui, #boss-battle-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent overlay */
            color: white;
            z-index: 100;
            border-radius: 20px; /* Match container border-radius */
        }

        /* Specific styling for the shop UI to ensure elements fit */
        #shop-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            /* Changed from space-between to center, and manage spacing with margins */
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center horizontally */
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent overlay */
            color: white;
            z-index: 100;
            border-radius: 20px;
            padding: 20px; /* Add some padding around the content */
            box-sizing: border-box; /* Include padding in the element's total width and height */
            overflow-y: auto; /* Allow scrolling if content truly overflows */
        }

        .hidden {
            display: none !important;
        }

        .button-primary {
            background-color: #FFD700; /* Gold-like color */
            color: #8B4513; /* SaddleBrown for text */
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            border: 3px solid #DAA520; /* Darker gold border */
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        .button-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4);
        }

        .game-info {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 50;
        }

        .game-info span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Basic styling for Lego-like elements */
        .lego-block {
            background-color: #FF4500; /* OrangeRed */
            border: 2px solid #CD3700;
            border-radius: 5px;
            box-shadow: inset 0 -3px 0 rgba(0,0,0,0.2), 0 3px 0 rgba(0,0,0,0.2);
        }

        .lego-coin {
            background-color: #FFD700; /* Gold */
            border-radius: 50%;
            border: 2px solid #DAA520;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }

        .lego-enemy {
            background-color: #9932CC; /* DarkOrchid */
            border-radius: 50%;
            border: 2px solid #8A2BE2;
            box-shadow: 0 0 10px rgba(153, 50, 204, 0.5);
        }

        /* Loading spinner */
        .loading-spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -30px;
            margin-left: -30px;
            z-index: 101;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-size: 1.5rem;
            z-index: 102;
        }

        #cheat-input-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        #cheatInput {
            background-color: #333;
            color: white;
            border: 2px solid #FFD700;
            border-radius: 5px;
            padding: 8px 12px;
            font-size: 1rem;
            outline: none;
            width: 150px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="hidden">
            <div class="loading-spinner"></div>
            <p class="mt-4">Loading Skirbys World...</p>
        </div>

        <!-- Intro Menu -->
        <div id="intro-menu">
            <h1 class="text-6xl font-extrabold mb-8 text-yellow-400 drop-shadow-lg">Skirby's World</h1>
            <p class="text-2xl mb-12 text-blue-200">Help Skirby on his blocky adventure!</p>
            <button id="startButton" class="button-primary">Start Adventure</button>
        </div>

        <!-- Game UI (Score, Health) -->
        <div id="game-ui" class="hidden">
            <div class="game-info">
                <span>Coins: <span id="coinCount">0</span></span>
                <span>Health: <span id="healthCount">100</span></span>
                <span>Level: <span id="levelCount">1</span></span>
            </div>
            <canvas id="gameCanvas"></canvas>
        </div>

        <!-- Shop UI (Initially hidden) -->
        <div id="shop-ui" class="hidden">
            <h2 class="text-5xl font-extrabold my-4 text-green-400 drop-shadow-lg">Skirby's Skill Shop</h2>
            <p class="text-xl mb-8 text-gray-200">Spend your coins wisely!</p>
            <!-- Modified grid for responsiveness -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 w-full max-w-2xl my-auto">
                <div class="bg-blue-600 p-6 rounded-lg shadow-xl text-center">
                    <h3 class="text-3xl font-bold text-white mb-2">Super Jump</h3>
                    <p class="text-lg text-blue-200 mb-4">Jump even higher!</p>
                    <p class="text-2xl font-bold text-yellow-300 mb-4">Cost: 20 Coins</p>
                    <button class="button-primary buy-skill-btn" data-skill="superJump" data-cost="20">Buy</button>
                </div>
                <div class="bg-red-600 p-6 rounded-lg shadow-xl text-center">
                    <h3 class="text-3xl font-bold text-white mb-2">Spin Attack</h3>
                    <p class="text-lg text-red-200 mb-4">Defeat enemies with a spin!</p>
                    <p class="text-2xl font-bold text-yellow-300 mb-4">Cost: 30 Coins</p>
                    <button class="button-primary buy-skill-btn" data-skill="spinAttack" data-cost="30">Buy</button>
                </div>
                 <div class="bg-purple-600 p-6 rounded-lg shadow-xl text-center">
                    <h3 class="text-3xl font-bold text-white mb-2">Punch Power</h3>
                    <p class="text-lg text-purple-200 mb-4">One-shot most enemies!</p>
                    <p class="text-2xl font-bold text-yellow-300 mb-4">Cost: 40 Coins</p>
                    <button class="button-primary buy-skill-btn" data-skill="punchPower" data-cost="40">Buy</button>
                </div>
                <div class="bg-teal-600 p-6 rounded-lg shadow-xl text-center">
                    <h3 class="text-3xl font-bold text-white mb-2">Flight</h3>
                    <p class="text-lg text-teal-200 mb-4">Soar through the skies!</p>
                    <p class="text-2xl font-bold text-yellow-300 mb-4">Cost: 50 Coins</p>
                    <button class="button-primary buy-skill-btn" data-skill="flight" data-cost="50">Buy</button>
                </div>
            </div>
            <button id="continueGameButton" class="button-primary mt-8">Continue Adventure</button>
        </div>

        <!-- Game Over UI (Initially hidden) -->
        <div id="game-over-ui" class="hidden">
            <h2 class="text-6xl font-extrabold mb-8 text-red-500 drop-shadow-lg">Game Over!</h2>
            <p class="text-2xl mb-12 text-gray-200">Skirby's adventure has ended.</p>
            <button id="restartButton" class="button-primary">Try Again</button>
        </div>

        <!-- Boss Battle UI (Initially hidden) -->
        <div id="boss-battle-ui" class="hidden">
            <h2 class="text-6xl font-extrabold mb-8 text-purple-400 drop-shadow-lg">Boss Battle!</h2>
            <p class="text-2xl mb-12 text-gray-200">Prepare to face the Soap Boss!</p>
            <button id="startBossBattleButton" class="button-primary">Engage!</button>
        </div>

        <!-- Cheat Code Input -->
        <div id="cheat-input-container" class="hidden">
            <label for="cheatInput" class="text-yellow-300 font-bold">Cheat:</label>
            <input type="text" id="cheatInput" placeholder="Enter code...">
        </div>
    </div>

    <script type="module">
    import { generateLevel, HANDCRAFTED_LEVEL_COUNT } from './levels/index.js';
    
        // Game Constants
    const CANVAS_WIDTH = 1200;
    const CANVAS_HEIGHT = 675; // 16:9 aspect ratio
    const TOTAL_HANDCRAFTED_LEVELS = HANDCRAFTED_LEVEL_COUNT;
    console.log(`Loaded ${TOTAL_HANDCRAFTED_LEVELS} handcrafted levels`);

        // Game State
        const GAME_STATE = {
            INTRO: 'intro',
            PLAYING: 'playing',
            SHOP: 'shop',
            GAME_OVER: 'gameOver',
            BOSS_BATTLE: 'bossBattle'
        };
        let currentState = GAME_STATE.INTRO;

        // HTML Elements
        const gameContainer = document.getElementById('game-container');
        const introMenu = document.getElementById('intro-menu');
        const gameUI = document.getElementById('game-ui');
        const shopUI = document.getElementById('shop-ui');
        const gameOverUI = document.getElementById('game-over-ui');
        const bossBattleUI = document.getElementById('boss-battle-ui');
        const startButton = document.getElementById('startButton');
        const gameCanvas = document.getElementById('gameCanvas');
        let gl = gameCanvas.getContext('webgl2', { premultipliedAlpha: false }) || gameCanvas.getContext('webgl', { premultipliedAlpha: false });
        let offscreenCanvas = null;
        let ctx = null;
        let webglRenderer = null;
        let useWebGL = Boolean(gl);

        if (useWebGL) {
            try {
                offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = CANVAS_WIDTH;
                offscreenCanvas.height = CANVAS_HEIGHT;
                ctx = offscreenCanvas.getContext('2d');
                webglRenderer = initWebGLRenderer(gl, CANVAS_WIDTH, CANVAS_HEIGHT);
            } catch (error) {
                console.warn('WebGL initialisation failed, reverting to 2D context.', error);
                gl = null;
                useWebGL = false;
                offscreenCanvas = null;
                webglRenderer = null;
            }
        }

        if (!useWebGL) {
            ctx = gameCanvas.getContext('2d');
        }
        const coinCountDisplay = document.getElementById('coinCount');
        const healthCountDisplay = document.getElementById('healthCount');
        const levelCountDisplay = document.getElementById('levelCount');
        const continueGameButton = document.getElementById('continueGameButton');
        const restartButton = document.getElementById('restartButton');
        const buySkillButtons = document.querySelectorAll('.buy-skill-btn');
        const startBossBattleButton = document.getElementById('startBossBattleButton');
        const loadingOverlay = document.getElementById('loading-overlay');
        const cheatInputContainer = document.getElementById('cheat-input-container');
        const cheatInput = document.getElementById('cheatInput');


        // SKIRBY PLAYER PROPERTIES
        const player = {
            x: 50,
            y: CANVAS_HEIGHT - 100, // Start on ground
            width: 58,
            height: 58,
            color: '#FF6347', // Tomato Red for Skirby (Lego-like)
            dx: 0,
            dy: 0,
            speed: 2.6,
            jumpPower: -21, // Base jump power (more hang time)
            gravity: 0.55,
            onGround: false,
            health: 100,
            coins: 0,
            skills: {
                superJump: false,
                spinAttack: false,
                punchPower: false,
                flight: false
            },
            isSpinning: false,
            isPunching: false,
            isFlying: false,
            flightFuel: 100, // For flight skill
            lastWalkSoundTime: 0,
            walkSoundCooldown: 200, // milliseconds
            isInvincible: false, // New: Invincibility flag
            invincibilityTimer: 0, // New: Timer for invincibility
            invincibilityDuration: 60, // New: Duration in frames (e.g., 1 second at 60 FPS)
            knockbackX: 0, // New: Horizontal knockback velocity
            knockbackY: 0, // New: Vertical knockback velocity
            facing: 1 // Direction Skirby is looking (1 right, -1 left)
        };

        function createLevelContext() {
            return {
                canvasWidth: CANVAS_WIDTH,
                canvasHeight: CANVAS_HEIGHT,
                playerWidth: player.width,
                playerHeight: player.height,
                playerJumpPower: player.jumpPower
            };
        }

        // Game variables
        let currentLevel = 1;
        let currentLevelData; // Stores the currently generated level data
        let keys = {};
        let gameLoopId; // To store the requestAnimationFrame ID
        let cameraX = 0; // Camera's X offset for scrolling
        let frameCounter = 0; // Global frame counter for animations

        // Background elements for parallax
        let clouds = [];
        let hills = [];
        let stars = []; // For boss battle

        // Sound effects setup
        let jumpSound;
        let walkSound;
        let enemyHitSound; // When player jumps on enemy
        let enemyDeathSound; // When enemy drops off screen

        /**
         * Initializes all game sound effects using Tone.js.
         */
        function setupSounds() {
            // Jump Sound: A short, rising tone
            jumpSound = new Tone.Synth({
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0,
                    release: 0.1
                }
            }).toDestination();

            // Walk Sound: A very short, low frequency click/thump
            walkSound = new Tone.Synth({
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.005,
                    decay: 0.05,
                    sustain: 0,
                    release: 0.05
                }
            }).toDestination();

            // Enemy Hit Sound (when jumped on): A quick, sharp pop
            enemyHitSound = new Tone.Synth({
                oscillator: { type: "square" },
                envelope: {
                    attack: 0.001,
                    decay: 0.1,
                    sustain: 0,
                    release: 0.05
                }
            }).toDestination();

            // Enemy Death Sound (when dropping off): A descending, fading tone
            enemyDeathSound = new Tone.Synth({
                oscillator: { type: "sawtooth" },
                envelope: {
                    attack: 0.01,
                    decay: 0.5,
                    sustain: 0,
                    release: 0.3
                }
            }).toDestination();
        }

        /** Plays the jump sound. */
        function playJumpSound() {
            jumpSound.triggerAttackRelease("C5", "8n"); // C5 for an 8th note
        }

        /** Plays the walk sound. */
        function playWalkSound() {
            const now = performance.now();
            if (now - player.lastWalkSoundTime > player.walkSoundCooldown) {
                walkSound.triggerAttackRelease("C3", "32n"); // Low C, very short
                player.lastWalkSoundTime = now;
            }
        }

        /** Plays the enemy hit sound. */
        function playEnemyHitSound() {
            enemyHitSound.triggerAttackRelease("G4", "16n"); // G4, short and sharp
        }

        /** Plays the enemy death sound. */
        function playEnemyDeathSound() {
            enemyDeathSound.triggerAttackRelease("C4", "0.5"); // C4, half second fade
            enemyDeathSound.triggerAttackRelease("C3", "0.8", Tone.now() + 0.2); // Descend to C3 after a delay
        }

        /**
         * Creates a shader for the provided source.
         * @param {WebGLRenderingContext} gl
         * @param {number} type
         * @param {string} source
         * @returns {WebGLShader}
         */
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                throw new Error('Failed to compile shader');
            }
            return shader;
        }

        /**
         * Links a program from vertex and fragment shader sources.
         * @param {WebGLRenderingContext} gl
         * @param {string} vertexSource
         * @param {string} fragmentSource
         * @returns {WebGLProgram}
         */
        function createProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                throw new Error('Failed to link WebGL program');
            }
            return program;
        }

        /**
         * Sets up a minimal WebGL presenter that applies lightweight effects before display.
         * @param {WebGLRenderingContext} gl
         * @param {number} width
         * @param {number} height
         */
        function initWebGLRenderer(gl, width, height) {
            const vertexSource = `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                void main() {
                    v_texCoord = a_texCoord;
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;
            const fragmentSource = `
                precision mediump float;
                uniform sampler2D u_texture;
                uniform float u_time;
                uniform float u_vignetteStrength;
                varying vec2 v_texCoord;
                void main() {
                    vec2 uv = v_texCoord;
                    vec4 baseColor = texture2D(u_texture, uv);
                    float vignette = smoothstep(u_vignetteStrength, 1.1, distance(uv, vec2(0.5)));
                    baseColor.rgb *= mix(1.15, 0.85, vignette);
                    baseColor.rgb += 0.025 * sin(u_time + vec3(uv.xy, uv.x + uv.y) * 3.14);
                    gl_FragColor = vec4(baseColor.rgb, 1.0);
                }
            `;

            const program = createProgram(gl, vertexSource, fragmentSource);
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
            const timeLocation = gl.getUniformLocation(program, 'u_time');
            const vignetteLocation = gl.getUniformLocation(program, 'u_vignetteStrength');
            const textureLocation = gl.getUniformLocation(program, 'u_texture');

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,
                 1, -1,
                -1,  1,
                -1,  1,
                 1, -1,
                 1,  1
            ]), gl.STATIC_DRAW);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 1,
                1, 1,
                0, 0,
                0, 0,
                1, 1,
                1, 0
            ]), gl.STATIC_DRAW);

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.useProgram(program);
            gl.uniform1i(textureLocation, 0);

            const enableAttributes = () => {
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.enableVertexAttribArray(texCoordLocation);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
            };

            const resize = (w, h) => {
                gl.viewport(0, 0, w, h);
            };

            resize(width, height);

            return {
                render(sourceCanvas, frame) {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sourceCanvas);

                    gl.useProgram(program);
                    enableAttributes();
                    gl.uniform1f(timeLocation, frame * 0.016);
                    gl.uniform1f(vignetteLocation, 0.55);

                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                },
                resize
            };
        }


        // Boss properties (Soap with a mustache)
        const boss = {
            x: CANVAS_WIDTH / 2 - 75,
            y: CANVAS_HEIGHT / 2 - 75,
            width: 150,
            height: 100,
            health: 300,
            maxHealth: 300,
            color: '#F0F8FF', // AliceBlue for soap
            mustacheColor: '#8B4513', // SaddleBrown
            eyeColor: '#000000',
            dx: 2,
            dy: 0,
            speed: 2,
            attackCooldown: 120, // Frames
            currentAttackCooldown: 0,
            isAttacking: false,
            attackType: 'none', // 'bubble', 'charge'
            bubbles: [],
            chargeTargetX: 0,
            chargeTargetY: 0,
            isCharging: false
        };

        // --- Game Initialization and State Management ---

        /**
         * Sets the current game state and updates UI visibility.
         * @param {string} newState - The new state to set (e.g., GAME_STATE.PLAYING).
         */
        function setGameState(newState) {
            currentState = newState;
            introMenu.classList.add('hidden');
            gameUI.classList.add('hidden');
            shopUI.classList.add('hidden');
            gameOverUI.classList.add('hidden');
            bossBattleUI.classList.add('hidden');
            loadingOverlay.classList.add('hidden');
            cheatInputContainer.classList.add('hidden'); // Always hide cheat input on state change

            // Cancel any existing game loop before setting new state
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }

            switch (currentState) {
                case GAME_STATE.INTRO:
                    introMenu.classList.remove('hidden');
                    break;
                case GAME_STATE.PLAYING:
                    gameUI.classList.remove('hidden');
                    gameCanvas.width = CANVAS_WIDTH; // Ensure canvas dimensions are set
                    gameCanvas.height = CANVAS_HEIGHT;
                    if (useWebGL && offscreenCanvas && webglRenderer) {
                        offscreenCanvas.width = CANVAS_WIDTH;
                        offscreenCanvas.height = CANVAS_HEIGHT;
                        webglRenderer.resize(CANVAS_WIDTH, CANVAS_HEIGHT);
                    }
                    initializeBackgroundElements(); // Initialize clouds and hills
                    startGameLoop(); // Always start game loop for PLAYING
                    break;
                case GAME_STATE.SHOP:
                    shopUI.classList.remove('hidden');
                    break;
                case GAME_STATE.GAME_OVER:
                    gameOverUI.classList.remove('hidden');
                    break;
                case GAME_STATE.BOSS_BATTLE:
                    gameUI.classList.remove('hidden'); // Ensure game canvas is visible
                    if (useWebGL && offscreenCanvas && webglRenderer) {
                        offscreenCanvas.width = CANVAS_WIDTH;
                        offscreenCanvas.height = CANVAS_HEIGHT;
                        webglRenderer.resize(CANVAS_WIDTH, CANVAS_HEIGHT);
                    }
                    initializeBackgroundElements(); // Initialize stars for boss battle
                    startGameLoop(); // Always start game loop for BOSS_BATTLE
                    break;
            }
        }

        /**
         * Resets player and game state for a new game or level.
         */
        function resetGame() {
            player.x = 50;
            player.y = CANVAS_HEIGHT - 100;
            player.dx = 0;
            player.dy = 0;
            player.health = 100;
            player.coins = 0;
            player.onGround = false;
            player.skills = {
                superJump: false,
                spinAttack: false,
                punchPower: false,
                flight: false
            };
            player.isSpinning = false;
            player.isPunching = false;
            player.isFlying = false;
            player.flightFuel = 100;
            player.isInvincible = false; // Reset invincibility
            player.invincibilityTimer = 0; // Reset invincibility timer
            player.knockbackX = 0; // Reset knockback
            player.knockbackY = 0; // Reset knockback
            player.facing = 1;
            currentLevel = 1;

            // Generate the first level
            currentLevelData = generateLevel(currentLevel, createLevelContext());
            initializeBackgroundElements(currentLevelData?.theme); // Re-initialize background elements for new game

            updateUI();
        }

        /**
         * Resets the positions and states of enemies and coins for the current level.
         */
        function resetLevelElements() {
            // This function is now mostly handled by generating a new level
            // when currentLevel increments.
            // However, we need to re-initialize player position etc.
            player.x = 50;
            player.y = CANVAS_HEIGHT - 100;
            player.dy = 0;
            player.onGround = false;
            player.isInvincible = false; // Reset invincibility
            player.invincibilityTimer = 0; // Reset invincibility timer
            player.knockbackX = 0; // Reset knockback
            player.knockbackY = 0; // Reset knockback
            player.facing = 1;
            cameraX = 0; // Reset camera for new level
            currentLevelData = generateLevel(currentLevel, createLevelContext()); // Generate new level data
            initializeBackgroundElements(currentLevelData?.theme); // Re-initialize background elements for new level
        }

        /**
         * Initializes clouds, hills, and stars for background.
         */
        function initializeBackgroundElements() {
            clouds = [];
            hills = [];
            stars = [];

            // Generate clouds
            for (let i = 0; i < 10; i++) { // 10 clouds
                clouds.push({
                    x: Math.random() * CANVAS_WIDTH * 2, // Can start off-screen
                    y: Math.random() * (CANVAS_HEIGHT / 2 - 50),
                    width: 80 + Math.random() * 100,
                    height: 30 + Math.random() * 40,
                    speed: 0.1 + Math.random() * 0.2, // Slower speed for parallax
                    color: 'rgba(255, 255, 255, 0.8)'
                });
            }

            // Generate hills (multiple layers for more depth)
            const hillColors = ['#6B8E23', '#8B4513', '#A0522D']; // OliveDrab, SaddleBrown, Sienna
            const hillHeights = [CANVAS_HEIGHT * 0.3, CANVAS_HEIGHT * 0.4, CANVAS_HEIGHT * 0.5];
            const hillSpeeds = [0.05, 0.1, 0.15]; // Slower speeds for distant hills

            for (let layer = 0; layer < 3; layer++) {
                for (let i = 0; i < 3; i++) { // A few hills per layer
                    hills.push({
                        x: Math.random() * CANVAS_WIDTH * 2,
                        y: CANVAS_HEIGHT - hillHeights[layer],
                        width: 200 + Math.random() * 300,
                        height: hillHeights[layer],
                        color: hillColors[layer],
                        speed: hillSpeeds[layer] // Parallax speed
                    });
                }
            }

            // Generate stars for boss battle
            for (let i = 0; i < 200; i++) { // 200 stars
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    radius: Math.random() * 1.5 + 0.5,
                    initialAlpha: Math.random() // For twinkling effect
                });
            }
        }


        // --- Event Listeners ---

        startButton.addEventListener('click', () => {
            // Resume AudioContext on user gesture
            Tone.start().then(() => {
                console.log("AudioContext resumed!");
                loadingOverlay.classList.remove('hidden');
                // Simulate loading time
                setTimeout(() => {
                    resetGame(); // Reset game state before starting
                    setGameState(GAME_STATE.PLAYING);
                }, 1000);
            }).catch(e => console.error("Error resuming AudioContext:", e));
        });

        continueGameButton.addEventListener('click', () => {
            loadingOverlay.classList.remove('hidden');
            setTimeout(() => {
                setGameState(GAME_STATE.PLAYING);
            }, 500);
        });

        restartButton.addEventListener('click', () => {
            loadingOverlay.classList.remove('hidden');
            setTimeout(() => {
                resetGame();
                setGameState(GAME_STATE.PLAYING);
            }, 1000);
        });

        startBossBattleButton.addEventListener('click', () => {
            loadingOverlay.classList.remove('hidden');
            setTimeout(() => {
                startBossBattle();
            }, 1000);
        });

        // Keyboard input handling for game and cheat toggle
        document.addEventListener('keydown', (e) => {
            // If the cheat input is focused, allow typing 'c' and other characters
            // Do NOT prevent default or toggle visibility if typing in the input.
            if (document.activeElement === cheatInput) {
                if (e.key === 'Enter') {
                    handleCheatCode(cheatInput.value.toLowerCase());
                    cheatInput.value = ''; // Clear input
                    cheatInputContainer.classList.add('hidden'); // Hide input
                    cheatInput.blur(); // Remove focus from input
                }
                return; // Don't process other game keys if typing in cheat input
            }

            // Toggle cheat input visibility when 'C' is pressed and input is NOT active
            if (e.key.toLowerCase() === 'c') {
                e.preventDefault(); // Prevent 'c' from being typed into game (if not in input)
                cheatInputContainer.classList.toggle('hidden');
                if (!cheatInputContainer.classList.contains('hidden')) {
                    cheatInput.focus(); // Focus the input when it appears
                } else {
                    cheatInput.value = ''; // Clear input when hidden
                }
                return; // Don't process 'c' for game movement
            }

            // Prevent repeated keydown events for game controls
            if (keys[e.key.toLowerCase()] === true) return;

            keys[e.key.toLowerCase()] = true;

            // Handle skill activation on key press (e.g., 'e' for spin, 'f' for punch)
            if (currentState === GAME_STATE.PLAYING || currentState === GAME_STATE.BOSS_BATTLE) {
                if (e.key.toLowerCase() === 'e' && player.skills.spinAttack && !player.isSpinning) {
                    player.isSpinning = true;
                    // Spin attack duration
                    setTimeout(() => player.isSpinning = false, 500);
                }
                if (e.key.toLowerCase() === 'f' && player.skills.punchPower && !player.isPunching) {
                    player.isPunching = true;
                    // Punch attack duration
                    setTimeout(() => player.isPunching = false, 300);
                }
                // Jump and walk sounds are now handled in the update loop based on player.onGround
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Function to handle cheat codes
        function handleCheatCode(code) {
            switch (code) {
                case 'level2':
                    currentLevel = 2;
                    resetLevelElements(); // Resets player position and generates new level
                    updateUI(); // Update UI immediately
                    setGameState(GAME_STATE.PLAYING);
                    displayMessageBox('Cheat Activated!', 'Jumped to Level 2!');
                    break;
                case 'level3':
                    currentLevel = 3;
                    resetLevelElements(); // Resets player position and new level
                    updateUI(); // Update UI immediately
                    setGameState(GAME_STATE.PLAYING);
                    displayMessageBox('Cheat Activated!', 'Jumped to Level 3!');
                    break;
                case 'add100': // Changed cheat code to add100
                    player.coins += 100;
                    updateUI();
                    displayMessageBox('Cheat Activated!', '100 coins added!');
                    break;
                case 'boss': // New cheat code for boss battle
                    currentLevel = 3; // Ensure level is set to 3 to correctly reflect progression
                    updateUI(); // Update UI immediately
                    displayMessageBox('Cheat Activated!', 'Teleporting to Boss Battle!');
                    startBossBattle(); // Directly start the boss battle
                    break;
                default:
                    displayMessageBox('Invalid Cheat', 'Code not recognized.');
                    break;
            }
        }

        // Shop button listeners
        buySkillButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const skill = e.target.dataset.skill;
                const cost = parseInt(e.target.dataset.cost);

                if (player.coins >= cost && !player.skills[skill]) {
                    player.coins -= cost;
                    player.skills[skill] = true;
                    e.target.innerText = 'Learned!';
                    e.target.disabled = true;
                    e.target.classList.remove('button-primary');
                    e.target.classList.add('bg-gray-500', 'cursor-not-allowed');
                    updateUI();
                    console.log(`Player bought ${skill}`);
                } else if (player.skills[skill]) {
                    console.log(`Player already has ${skill}`);
                } else {
                    console.log(`Not enough coins for ${skill}`);
                    // Potentially add a visual feedback for not enough coins
                }
            });
        });

        // --- Game Loop and Core Logic ---

        /**
         * The main game loop, called repeatedly using requestAnimationFrame.
         */
        function gameLoop() {
            update();
            draw();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        /**
         * Starts the game loop.
         */
        function startGameLoop() {
            if (!gameLoopId) {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }

        /**
         * Updates game state: player movement, physics, collisions, enemy logic.
         */
        function update() {
            frameCounter++; // Increment frame counter

            if (currentState !== GAME_STATE.PLAYING && currentState !== GAME_STATE.BOSS_BATTLE) return;

            // Handle invincibility timer
            if (player.isInvincible) {
                player.invincibilityTimer--;
                if (player.invincibilityTimer <= 0) {
                    player.isInvincible = false;
                }
            }

            const wasOnGround = player.onGround;
            const leftPressed = keys['a'] || keys['arrowleft'];
            const rightPressed = keys['d'] || keys['arrowright'];
            const movingLeft = leftPressed && !rightPressed;
            const movingRight = rightPressed && !leftPressed;
            const groundAcceleration = player.speed * 0.20;
            const airAcceleration = player.speed * 0.14;
            const groundFriction = 0.6;
            const airDrag = 0.985;
            const maxGroundSpeed = player.speed;
            const maxAirSpeed = player.speed * 1.45;

            if (movingLeft) {
                player.dx -= wasOnGround ? groundAcceleration : airAcceleration;
                if (player.dx < -(wasOnGround ? maxGroundSpeed : maxAirSpeed)) {
                    player.dx = -(wasOnGround ? maxGroundSpeed : maxAirSpeed);
                }
                player.facing = -1;
            } else if (movingRight) {
                player.dx += wasOnGround ? groundAcceleration : airAcceleration;
                if (player.dx > (wasOnGround ? maxGroundSpeed : maxAirSpeed)) {
                    player.dx = (wasOnGround ? maxGroundSpeed : maxAirSpeed);
                }
                player.facing = 1;
            } else {
                if (wasOnGround) {
                    player.dx *= groundFriction;
                    if (Math.abs(player.dx) < 0.05) player.dx = 0;
                } else {
                    player.dx *= airDrag;
                }
            }

            if (wasOnGround && (movingLeft || movingRight)) {
                playWalkSound();
            }

            // Player vertical movement (Jump)
            // Super Jump implementation
            let jumpedThisFrame = false;
            if (keys[' '] && player.onGround) {
                player.dy = player.skills.superJump ? player.jumpPower * 1.5 : player.jumpPower;
                player.onGround = false; // Player is now in the air
                playJumpSound(); // Play jump sound immediately on jump
                jumpedThisFrame = true;
            }

            if (jumpedThisFrame) {
                const launchBoost = player.facing * player.speed * 1.15;
                if (Math.abs(player.dx) < Math.abs(launchBoost)) {
                    player.dx = launchBoost;
                }
            }

            if (!player.onGround) {
                if (player.dx > maxAirSpeed) player.dx = maxAirSpeed;
                if (player.dx < -maxAirSpeed) player.dx = -maxAirSpeed;
            }

            if (player.dx > 0.1) {
                player.facing = 1;
            } else if (player.dx < -0.1) {
                player.facing = -1;
            }

            // Flight skill implementation
            if (player.skills.flight) {
                if (keys['w'] && player.flightFuel > 0) {
                    player.dy = -player.speed * 0.8; // Slower upward movement when flying
                    player.flightFuel -= 0.5; // Consume fuel
                    player.isFlying = true;
                    // Prevent player from going above the top of the canvas
                    if (player.y < 0) player.y = 0;
                } else if (keys['s'] && player.flightFuel > 0) {
                    player.dy = player.speed * 0.8; // Slower downward movement when flying
                    player.flightFuel -= 0.5; // Consume fuel
                    player.isFlying = true;
                    // Prevent player from going below the bottom of the canvas (unless falling)
                    if (player.y + player.height > CANVAS_HEIGHT) player.y = CANVAS_HEIGHT - player.height;
                } else {
                    player.isFlying = false;
                }

                // Regenerate fuel when not actively flying or when fuel is low
                if (!player.isFlying && player.flightFuel < 100) {
                    player.flightFuel += 0.2;
                    if (player.flightFuel > 100) player.flightFuel = 100;
                }
            } else {
                player.isFlying = false; // Ensure this is false if skill not owned
            }


            // Apply gravity if not flying
            if (!player.isFlying) {
                player.dy += player.gravity;
            }


            // Update player position based on dx and dy
            player.x += player.dx;
            player.y += player.dy;

            // Apply knockback
            player.x += player.knockbackX;
            player.y += player.knockbackY;
            // Decay knockback
            player.knockbackX *= 0.9; // Reduce knockback over time
            player.knockbackY *= 0.9;
            // Stop knockback if it's very small
            if (Math.abs(player.knockbackX) < 0.1) player.knockbackX = 0;
            if (Math.abs(player.knockbackY) < 0.1) player.knockbackY = 0;


            // Boundary checks for player
            if (player.x < 0) player.x = 0;
            // Keep player within canvas during boss battle (fixed arena)
            if (currentState === GAME_STATE.BOSS_BATTLE && player.x + player.width > CANVAS_WIDTH) {
                player.x = CANVAS_WIDTH - player.width;
            }

            // Update camera position based on player (only relevant for PLAYING state)
            if (currentState === GAME_STATE.PLAYING && currentLevelData) {
                cameraX = player.x - CANVAS_WIDTH / 2 + player.width / 2;
                const levelTotalWidth = currentLevelData.levelTotalWidth;
                if (cameraX < 0) cameraX = 0;
                if (cameraX > levelTotalWidth - CANVAS_WIDTH) {
                    cameraX = levelTotalWidth - CANVAS_WIDTH;
                }
            }

            // Reset onGround at the start of each frame before checking collisions
            player.onGround = false;

            // Collision detection and resolution for PLAYING state
            if (currentState === GAME_STATE.PLAYING && currentLevelData) {
                if (currentLevelData.hazards && currentLevelData.hazards.length) {
                    drawHazards(ctx, cameraX, currentLevelData.hazards, frameCounter);
                }

                currentLevelData.platforms.forEach(platform => {
                    if (checkCollision(player, platform)) {
                        // Calculate overlap to determine collision direction
                        const xOverlap = Math.min(player.x + player.width, platform.x + platform.width) - Math.max(player.x, platform.x);
                        const yOverlap = Math.min(player.y + player.height, platform.y + platform.height) - Math.max(player.y, platform.y);

                        // Prioritize vertical collision if Y overlap is smaller (meaning player landed/jumped into it)
                        if (yOverlap < xOverlap) {
                            // Falling onto a platform
                            if (player.dy > 0) {
                                player.y = platform.y - player.height; // Snap to top
                                player.dy = 0; // Stop falling
                                player.onGround = true; // Player is on ground
                            }
                            // Jumping into the bottom of a platform
                            else if (player.dy < 0) {
                                player.y = platform.y + platform.height; // Snap to bottom
                                player.dy = 0; // Stop rising
                            }
                        }
                        // Otherwise, it's a horizontal collision
                        else {
                            if (player.dx > 0) { // Moving right, hit left side of platform
                                player.x = platform.x - player.width;
                                player.dx = 0;
                            } else if (player.dx < 0) { // Moving left, hit right side of platform
                                player.x = platform.x + platform.width;
                                player.dx = 0;
                            }
                        }
                    }
                });

                // Fall off screen (Game Over)
                if (player.y + player.height > CANVAS_HEIGHT) {
                    player.health = 0; // Instant death
                }

                // Coin collection
                currentLevelData.coins.forEach(coin => {
                    if (!coin.collected && checkCollision(player, { x: coin.x - coin.radius, y: coin.y - coin.radius, width: coin.radius * 2, height: coin.radius * 2 })) {
                        coin.collected = true;
                        player.coins += 1;
                        updateUI();
                    }
                });

                // Enemy movement and collision
                currentLevelData.enemies.forEach(enemy => {
                    if (enemy.isDying) {
                        enemy.y += enemy.dy;
                        enemy.dy += player.gravity; // Apply gravity to falling enemy
                        enemy.width = Math.max(0, enemy.width - 0.5); // Shrink
                        enemy.height = Math.max(0, enemy.height - 0.5); // Shrink
                        return; // Skip normal enemy logic if dying
                    }

                    // Simple horizontal patrol for enemies
                    enemy.x += enemy.dx;
                    if (enemy.x <= enemy.initialX - enemy.range || enemy.x + enemy.width >= enemy.initialX + enemy.range) {
                        enemy.dx *= -1; // Reverse direction
                    }

                    if (checkCollision(player, enemy)) {
                        // Check if player jumped on top of the enemy
                        const playerBottom = player.y + player.height;
                        const enemyTop = enemy.y;
                        const playerPrevBottom = playerBottom - player.dy; // Player's bottom in previous frame

                        if (player.dy > 0 && playerPrevBottom <= enemyTop + enemy.height / 2) { // Landing on top half
                            playEnemyHitSound();
                            enemy.isDying = true;
                            enemy.dy = 5; // Start falling
                            player.dy = player.jumpPower * 0.7; // Bounce player up
                            player.onGround = false; // Player is now in air
                            playEnemyDeathSound(); // Play death sound for the drop
                            console.log('Enemy stomped!');
                        } else if (player.isSpinning && player.skills.spinAttack) {
                            // Defeat enemy with spin attack
                            playEnemyHitSound();
                            enemy.isDying = true;
                            enemy.dy = 5; // Start falling
                            playEnemyDeathSound();
                            console.log('Enemy defeated by Spin Attack!');
                        } else if (player.isPunching && player.skills.punchPower) {
                            // Defeat enemy with punch attack
                            playEnemyHitSound();
                            enemy.isDying = true;
                            enemy.dy = 5; // Start falling
                            playEnemyDeathSound();
                            console.log('Enemy defeated by Punch Power!');
                        } else if (!player.isInvincible) { // Only take damage if not invincible
                            // Player takes damage from side/bottom collision
                            player.health -= 1; // Adjust damage as needed
                            updateUI();
                            // Apply knockback velocity
                            player.knockbackX = (player.x > enemy.x ? 1 : -1) * 8; // Initial horizontal knockback strength
                            player.knockbackY = -8; // Initial upward knockback strength
                            player.isInvincible = true;
                            player.invincibilityTimer = player.invincibilityDuration;
                            console.log('Player hit by enemy! Health:', player.health);
                        }
                    }
                });
                // Filter out defeated enemies that have fallen off screen
                currentLevelData.enemies = currentLevelData.enemies.filter(enemy => enemy.y < CANVAS_HEIGHT);

                // Hazard interactions
                if (currentLevelData.hazards && currentLevelData.hazards.length) {
                    currentLevelData.hazards.forEach(hazard => {
                        const overlapsX = player.x + player.width > hazard.x && player.x < hazard.x + hazard.width;
                        const overlapsY = player.y + player.height > hazard.y && player.y < hazard.y + hazard.height;
                        if (!overlapsX || !overlapsY) {
                            return;
                        }

                        const applyInvincibility = (duration) => {
                            player.isInvincible = true;
                            player.invincibilityTimer = Math.max(player.invincibilityTimer, duration);
                        };

                        if (hazard.type === 'water') {
                            player.onGround = false;
                            player.dy = Math.min(player.dy + 0.4, 6);
                            player.dx += (hazard.flowSpeed ?? 1) * 0.32 * (hazard.direction ?? 1);
                            const maxY = hazard.y + hazard.height - player.height + 6;
                            if (player.y < hazard.y) {
                                player.y = hazard.y - player.height * 0.6;
                            } else if (player.y > maxY) {
                                player.y = maxY;
                            }
                            if (!player.isInvincible) {
                                const damage = Math.max(1, hazard.damage ?? 1);
                                player.health = Math.max(0, player.health - damage);
                                updateUI();
                                applyInvincibility(24);
                            }
                        } else if (hazard.type === 'lava') {
                            if (!player.isInvincible) {
                                const damage = Math.max(1, hazard.damage ?? 2);
                                player.health = Math.max(0, player.health - damage);
                                updateUI();
                                const knockback = hazard.knockback || { x: 0, y: -14 };
                                player.knockbackX = knockback.x;
                                player.knockbackY = knockback.y;
                                applyInvincibility(36);
                            }
                        }
                    });
                }

                // Check for level completion (reaching exit)
                const isCollidingWithExit = checkCollision(player, currentLevelData.exit);

                if (isCollidingWithExit) {
                    console.log('Collision with Exit detected! Proceeding to next state.'); // Debug log
                    // Temporarily change exit color to red to confirm collision visually
                    currentLevelData.exit.color = 'red';
                    // Continue through handcrafted levels before triggering the boss battle
                    if (currentLevel < TOTAL_HANDCRAFTED_LEVELS) {
                        currentLevel++;
                        resetLevelElements(); // Generate new level
                        updateUI();
                        setGameState(GAME_STATE.SHOP); // Go to shop after level
                        console.log('Level Complete! Moving to Shop.');
                    } else {
                        // All levels complete, go to boss battle
                        setGameState(GAME_STATE.BOSS_BATTLE);
                        console.log('Handcrafted run complete! Time for the Boss Battle!');
                    }
                } else {
                    // Reset exit color if not colliding, to revert from red debug color
                    if (currentLevelData.exit.color !== currentLevelData.exit.originalColor) {
                        currentLevelData.exit.color = currentLevelData.exit.originalColor;
                    }
                }
            } else if (currentState === GAME_STATE.BOSS_BATTLE) {
                // Ground for player in boss battle (fixed platform at bottom)
                const groundY = CANVAS_HEIGHT - 40; // Example ground level
                if (player.y + player.height > groundY) {
                    player.y = groundY - player.height;
                    player.dy = 0;
                    player.onGround = true;
                }
            }

            // Check for Game Over
            if (player.health <= 0) {
                setGameState(GAME_STATE.GAME_OVER);
            }

            // Boss battle update logic
            if (currentState === GAME_STATE.BOSS_BATTLE) {
                updateBossBattle();
            }
        }

        /**
         * Draws all game elements onto the canvas.
         */
        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // Clear canvas

            // In boss battle, player is drawn at fixed position relative to canvas, not cameraX
            const playerDrawX = (currentState === GAME_STATE.BOSS_BATTLE) ? player.x : player.x - cameraX;

            // Draw background based on current state
            if (currentState === GAME_STATE.PLAYING) {
                const handcrafted = Boolean(currentLevelData && currentLevelData.layout === 'handcrafted_meadow');
                const skyStops = currentLevelData?.skyGradientStops;
                if (skyStops && skyStops.length) {
                    drawGradientSky(ctx, skyStops);
                } else {
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
                    skyGradient.addColorStop(0, '#87CEEB');
                    skyGradient.addColorStop(0.7, '#ADD8E6');
                    skyGradient.addColorStop(1, '#B0E0E6');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                }

                if (handcrafted && currentLevelData?.backdrops) {
                    drawHandcraftedBackdrops(ctx, cameraX, currentLevelData.backdrops);
                } else {
                    drawHills(ctx, cameraX);
                }

                drawClouds(ctx, cameraX);

                if (handcrafted && currentLevelData?.canopySegments) {
                    drawHandcraftedCanopy(ctx, cameraX, currentLevelData.canopySegments);
                }

            } else if (currentState === GAME_STATE.BOSS_BATTLE) {
                // Nebula background
                const nebulaGradient = ctx.createRadialGradient(
                    CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 50,
                    CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) / 2
                );
                nebulaGradient.addColorStop(0, '#4B0082'); // Indigo center
                nebulaGradient.addColorStop(0.5, '#6A0DAD'); // DarkOrchid
                nebulaGradient.addColorStop(1, '#191970'); // MidnightBlue
                ctx.fillStyle = nebulaGradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                drawStars(ctx, frameCounter); // Pass frameCounter for twinkling
            }


            // Draw current level elements (only in PLAYING state)
            if (currentState === GAME_STATE.PLAYING && currentLevelData) {
                currentLevelData.platforms.forEach(platform => {
                    if (platform.texture === 'strata' && platform.strataColors) {
                        drawStrataPlatform(ctx, platform, cameraX);
                        return;
                    }

                    ctx.fillStyle = platform.color || '#8BC34A';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 5;
                    ctx.shadowOffsetX = 3;
                    ctx.shadowOffsetY = 3;
                    ctx.fillRect(platform.x - cameraX, platform.y, platform.width, platform.height);
                    ctx.shadowColor = 'transparent';

                    if (platform.noStuds) {
                        return;
                    }

                    const studSize = 5;
                    const studColorTop = 'rgba(255,255,255,0.3)';
                    const studColorSide = 'rgba(0,0,0,0.15)';
                    for (let i = 0; i < platform.width; i += 15) {
                        if (i + studSize < platform.width) {
                            ctx.fillStyle = 'rgba(0,0,0,0.2)';
                            ctx.beginPath();
                            ctx.arc(platform.x + i + studSize - cameraX, platform.y + studSize, studSize, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.fillStyle = studColorTop;
                            ctx.beginPath();
                            ctx.arc(platform.x + i + studSize - cameraX - 1, platform.y + studSize - 1, studSize * 0.7, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.fillStyle = studColorSide;
                            ctx.beginPath();
                            ctx.arc(platform.x + i + studSize - cameraX + 1, platform.y + studSize + 1, studSize * 0.7, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });

                // Draw coins
                currentLevelData.coins.forEach(coin => {
                    if (!coin.collected) {
                        ctx.fillStyle = '#FFD700'; // Gold
                        ctx.beginPath();
                        ctx.arc(coin.x - cameraX, coin.y, coin.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#DAA520'; // Darker gold border
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });

                // Draw enemies
                currentLevelData.enemies.forEach(enemy => {
                    if (enemy.isDying) return; // Don't draw if dying

                    // Radial gradient for spherical look
                    const outerColor = enemy.color || '#8A2BE2';
                    const enemyGradient = ctx.createRadialGradient(
                        enemy.x + enemy.width / 2 - cameraX, enemy.y + enemy.height / 2, enemy.width * 0.1,
                        enemy.x + enemy.width / 2 - cameraX, enemy.y + enemy.height / 2, enemy.width * 0.5
                    );
                    enemyGradient.addColorStop(0, 'rgba(255,255,255,0.85)');
                    enemyGradient.addColorStop(1, outerColor);
                    ctx.fillStyle = enemyGradient;

                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width / 2 - cameraX, enemy.y + enemy.height / 2, enemy.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Add simple eyes with highlights
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width / 2 - 5 - cameraX, enemy.y + enemy.height / 2 - 5, 3, 0, Math.PI * 2);
                    ctx.arc(enemy.x + enemy.width / 2 + 5 - cameraX, enemy.y + enemy.height / 2 - 5, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width / 2 - 5 - cameraX, enemy.y + enemy.height / 2 - 5, 1.5, 0, Math.PI * 2);
                    ctx.arc(enemy.x + enemy.width / 2 + 5 - cameraX, enemy.y + enemy.height / 2 - 5, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye highlights
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width / 2 - 5 - cameraX + 1, enemy.y + enemy.height / 2 - 5 - 1, 0.8, 0, Math.PI * 2);
                    ctx.arc(enemy.x + enemy.width / 2 + 5 - cameraX + 1, enemy.y + enemy.height / 2 - 5 - 1, 0.8, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw exit
                ctx.fillStyle = currentLevelData.exit.color; // Use current color (might be red for debug)
                ctx.fillRect(currentLevelData.exit.x - cameraX, currentLevelData.exit.y, currentLevelData.exit.width, currentLevelData.exit.height);
                ctx.fillStyle = 'white';
                ctx.font = '16px Inter';
                ctx.fillText('EXIT', currentLevelData.exit.x + 5 - cameraX, currentLevelData.exit.y + currentLevelData.exit.height / 2 + 5);
            }

            const moveFactor = player.speed !== 0 ? (player.dx + player.knockbackX) / player.speed : 0;
            drawSkirbyCharacter(ctx, playerDrawX, player.y, player.width, player.height, frameCounter, {
                facing: player.facing,
                move: moveFactor,
                airborne: !player.onGround,
                punching: player.isPunching,
                spinning: player.isSpinning,
                dy: player.dy
            });


            // Draw skill effects
            if (player.isSpinning) {
                ctx.save(); // Save the current canvas state
                ctx.translate(playerDrawX + player.width / 2, player.y + player.height / 2); // Move origin to player center

                // Larger, faster rotating inner circle
                ctx.rotate(frameCounter * 0.2); // Faster rotation
                ctx.strokeStyle = `rgba(255, 255, 0, ${0.9 + Math.sin(frameCounter * 0.25) * 0.1})`; // Yellow glow with more dramatic pulsing alpha
                ctx.lineWidth = 8; // Thicker line
                ctx.beginPath();
                ctx.arc(0, 0, player.width * 1.0, 0, Math.PI * 2); // Larger radius
                ctx.stroke();

                // Even larger, slower, opposite rotating outer circle
                ctx.rotate(-frameCounter * 0.08); // Slower, opposite rotation
                ctx.strokeStyle = `rgba(255, 165, 0, ${0.7 + Math.sin(frameCounter * 0.2) * 0.2})`; // Orange-yellow glow with pulsing alpha
                ctx.lineWidth = 6; // Thicker line
                ctx.beginPath();
                ctx.arc(0, 0, player.width * 1.5, 0, Math.PI * 2); // Even larger radius
                ctx.stroke();

                // Add a third, very large, very slow rotating circle for a wider aura
                ctx.rotate(frameCounter * 0.03); // Very slow rotation
                ctx.strokeStyle = `rgba(255, 220, 0, ${0.5 + Math.sin(frameCounter * 0.1) * 0.15})`; // Lighter yellow, subtle pulse
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, player.width * 2.0, 0, Math.PI * 2); // Much larger radius
                ctx.stroke();

                ctx.restore(); // Restore the canvas state
            }
            if (player.isPunching) {
                // Punch effect - a much larger, more explosive burst
                const maxBurstRadius = 100; // Much larger max radius
                const currentFrameInCycle = frameCounter % 15; // Longer animation cycle for more 'oomph'
                const burstRadius = (currentFrameInCycle / 15) * maxBurstRadius;
                const burstAlpha = 1 - (currentFrameInCycle / 15); // Fades out

                // Outer, orange burst
                ctx.fillStyle = `rgba(255, 100, 0, ${burstAlpha})`; // Orange, fading
                ctx.beginPath();
                ctx.arc(playerDrawX + player.width + 10, player.y + player.height / 2, burstRadius, 0, Math.PI * 2);
                ctx.fill();

                // Inner, yellow core of the burst
                const innerBurstRadius = burstRadius * 0.7; // Slightly smaller inner circle
                ctx.fillStyle = `rgba(255, 255, 0, ${burstAlpha * 0.8})`; // Yellow, fading
                ctx.beginPath();
                ctx.arc(playerDrawX + player.width + 10, player.y + player.height / 2, innerBurstRadius, 0, Math.PI * 2);
                ctx.fill();

                // Small, bright center for the initial impact
                const coreRadius = burstRadius * 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${burstAlpha})`; // White hot center
                ctx.beginPath();
                ctx.arc(playerDrawX + player.width + 10, player.y + player.height / 2, coreRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            if (player.skills.flight) {
                // Draw flight fuel bar
                ctx.fillStyle = 'gray';
                ctx.fillRect(playerDrawX, player.y - 15, player.width, 5);
                ctx.fillStyle = 'cyan';
                ctx.fillRect(playerDrawX, player.y - 15, player.width * (player.flightFuel / 100), 5);
            }


            // Draw boss battle elements if in boss state
            if (currentState === GAME_STATE.BOSS_BATTLE) {
                drawBossBattle();
            }

            if (useWebGL && webglRenderer && offscreenCanvas) {
                webglRenderer.render(offscreenCanvas, frameCounter);
            }
        }

        /**
         * Updates the UI elements like coin count, health, and level.
         */
        function updateUI() {
            coinCountDisplay.innerText = player.coins;
            healthCountDisplay.innerText = player.health;
            levelCountDisplay.innerText = currentLevel;
        }

        /**
         * Checks for AABB collision between two rectangles.
         * @param {object} rect1 - First rectangle {x, y, width, height}.
         * @param {object} rect2 - Second rectangle {x, y, width, height}.
         * @returns {boolean} True if collision occurs, false otherwise.
         */
        function checkCollision(rect1, rect2) {
            // Check if rectangles overlap on X axis
            const xOverlap = rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x;
            // Check if rectangles overlap on Y axis, using >= for the bottom edge
            const yOverlap = rect1.y < rect2.y + rect2.height && rect1.y + rect1.height >= rect2.y;

            return xOverlap && yOverlap;
        }

        // --- Background Drawing Functions ---

        function drawHazards(ctx, cameraX, hazards, frameCounter) {
            hazards.forEach(hazard => {
                const drawX = hazard.x - cameraX;

                if (hazard.type === 'water') {
                    const waterGradient = ctx.createLinearGradient(0, hazard.y, 0, hazard.y + hazard.height);
                    waterGradient.addColorStop(0, 'rgba(150, 220, 255, 0.95)');
                    waterGradient.addColorStop(0.4, 'rgba(70, 160, 220, 0.9)');
                    waterGradient.addColorStop(1, 'rgba(15, 70, 150, 0.95)');
                    ctx.fillStyle = waterGradient;
                    ctx.fillRect(drawX, hazard.y, hazard.width, hazard.height);

                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(drawX, hazard.y);
                    const waveSegments = Math.max(6, Math.floor(hazard.width / 32));
                    for (let i = 0; i <= waveSegments; i++) {
                        const segmentX = drawX + (i / waveSegments) * hazard.width;
                        const phase = frameCounter * 0.08 + (segmentX - drawX) / (hazard.waveLength ?? 140);
                        const crest = Math.sin(phase) * (hazard.waveAmplitude ?? 12);
                        ctx.lineTo(segmentX, hazard.y + crest);
                    }
                    ctx.lineTo(drawX + hazard.width, hazard.y + hazard.height);
                    ctx.lineTo(drawX, hazard.y + hazard.height);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                    ctx.fill();
                    ctx.restore();
                } else if (hazard.type === 'lava') {
                    ctx.save();
                    ctx.shadowColor = `rgba(255, 120, 0, ${hazard.glow ?? 0.65})`;
                    ctx.shadowBlur = 28;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    const lavaGradient = ctx.createLinearGradient(0, hazard.y, 0, hazard.y + hazard.height);
                    lavaGradient.addColorStop(0, 'rgba(255, 230, 130, 0.95)');
                    lavaGradient.addColorStop(0.4, 'rgba(255, 120, 30, 0.95)');
                    lavaGradient.addColorStop(1, 'rgba(120, 0, 0, 1)');
                    ctx.fillStyle = lavaGradient;
                    ctx.fillRect(drawX, hazard.y, hazard.width, hazard.height);
                    ctx.shadowColor = 'transparent';

                    const pulse = 4 + Math.sin(frameCounter * (hazard.pulseSpeed ?? 0.16)) * 4;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
                    ctx.fillRect(drawX, hazard.y + hazard.height - pulse, hazard.width, 2);
                    ctx.restore();
                }
            });
        }

        /**
         * Draws clouds with parallax effect.
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context.
         * @param {number} cameraX The current camera X position.
         */
        function drawClouds(ctx, cameraX) {
            const levelWidth = currentLevelData?.levelTotalWidth ?? CANVAS_WIDTH;
            clouds.forEach(cloud => {
                const drawX = cloud.x - cameraX * cloud.speed;
                // Wrap clouds around the level width to create infinite scrolling
                if (drawX + cloud.width < 0) {
                    cloud.x += levelWidth + CANVAS_WIDTH; // Reset far right
                } else if (drawX > CANVAS_WIDTH + cloud.width) {
                    cloud.x -= levelWidth + CANVAS_WIDTH; // Reset far left
                }

                // Apply a radial gradient for cloud volume
                const cloudGradient = ctx.createRadialGradient(
                    drawX + cloud.width * 0.5, cloud.y + cloud.height * 0.5, cloud.width * 0.1,
                    drawX + cloud.width * 0.5, cloud.y + cloud.height * 0.5, cloud.width * 0.6
                );
                cloudGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)'); // Brighter center
                cloudGradient.addColorStop(1, 'rgba(255, 255, 255, 0.6)'); // Softer edges
                ctx.fillStyle = cloudGradient;

                ctx.beginPath();
                // More organic cloud shape using multiple bezier curves
                ctx.moveTo(drawX, cloud.y + cloud.height * 0.5);
                ctx.bezierCurveTo(
                    drawX - cloud.width * 0.1, cloud.y + cloud.height * 0.2,
                    drawX + cloud.width * 0.1, cloud.y - cloud.height * 0.2,
                    drawX + cloud.width * 0.3, cloud.y - cloud.height * 0.1
                );
                ctx.bezierCurveTo(
                    drawX + cloud.width * 0.5, cloud.y - cloud.height * 0.3,
                    drawX + cloud.width * 0.7, cloud.y - cloud.height * 0.2,
                    drawX + cloud.width, cloud.y + cloud.height * 0.3
                );
                ctx.bezierCurveTo(
                    drawX + cloud.width * 0.9, cloud.y + cloud.height * 0.8,
                    drawX + cloud.width * 0.1, cloud.y + cloud.height * 0.9,
                    drawX, cloud.y + cloud.height * 0.5
                );
                ctx.closePath();
                ctx.fill();
            });
        }

        /**
         * Draws hills with parallax effect.
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context.
         * @param {number} cameraX The current camera X position.
         */
        function drawHills(ctx, cameraX) {
            const levelWidth = currentLevelData?.levelTotalWidth ?? CANVAS_WIDTH;
            hills.forEach(hill => {
                const drawX = hill.x - cameraX * hill.speed;
                // Wrap hills around the level width
                if (drawX + hill.width < 0) {
                    hill.x += levelWidth + CANVAS_WIDTH;
                } else if (drawX > CANVAS_WIDTH + hill.width) {
                    hill.x -= levelWidth + CANVAS_WIDTH;
                }

                ctx.fillStyle = hill.color;
                ctx.beginPath();
                ctx.moveTo(drawX, hill.y);
                // More organic hill shape
                ctx.bezierCurveTo(
                    drawX + hill.width * 0.1, hill.y - hill.height * 0.2,
                    drawX + hill.width * 0.3, hill.y - hill.height * 0.7,
                    drawX + hill.width * 0.5, hill.y - hill.height * 0.5
                );
                ctx.bezierCurveTo(
                    drawX + hill.width * 0.7, hill.y - hill.height * 0.8,
                    drawX + hill.width * 0.9, hill.y - hill.height * 0.3,
                    drawX + hill.width, hill.y
                );
                ctx.lineTo(drawX + hill.width, CANVAS_HEIGHT);
                ctx.lineTo(drawX, CANVAS_HEIGHT);
                ctx.closePath();
                ctx.fill();

                // Add subtle shading at the base of the hill
                const shadeGradient = ctx.createLinearGradient(drawX, hill.y, drawX, CANVAS_HEIGHT);
                shadeGradient.addColorStop(0, 'rgba(0,0,0,0)');
                shadeGradient.addColorStop(1, 'rgba(0,0,0,0.1)');
                ctx.fillStyle = shadeGradient;
                ctx.beginPath();
                ctx.moveTo(drawX, hill.y);
                ctx.bezierCurveTo(
                    drawX + hill.width * 0.1, hill.y - hill.height * 0.2,
                    drawX + hill.width * 0.3, hill.y - hill.height * 0.7,
                    drawX + hill.width * 0.5, hill.y - hill.height * 0.5
                );
                ctx.bezierCurveTo(
                    drawX + hill.width * 0.7, hill.y - hill.height * 0.8,
                    drawX + hill.width * 0.9, hill.y - hill.height * 0.3,
                    drawX + hill.width, hill.y
                );
                ctx.lineTo(drawX + hill.width, CANVAS_HEIGHT);
                ctx.lineTo(drawX, CANVAS_HEIGHT);
                ctx.closePath();
                ctx.fill();
            });
        }

        function traceRoundedRect(ctx, x, y, width, height, radius) {
            const r = Math.max(0, Math.min(radius, width / 2, height / 2));
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + width - r, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + r);
            ctx.lineTo(x + width, y + height - r);
            ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
            ctx.lineTo(x + r, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawGradientSky(ctx, stops) {
            const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            stops.forEach(stop => gradient.addColorStop(stop.offset, stop.color));
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        function drawHandcraftedBackdrops(ctx, cameraX, backdrops) {
            const parallax = 0.35;
            backdrops.forEach(backdrop => {
                const drawX = backdrop.x - cameraX * parallax;
                const drawY = backdrop.y;
                const gradient = ctx.createLinearGradient(0, drawY, 0, drawY + backdrop.height);
                backdrop.gradient.forEach(stop => gradient.addColorStop(stop.offset, stop.color));
                ctx.save();
                traceRoundedRect(ctx, drawX, drawY, backdrop.width, backdrop.height, backdrop.roundedRadius);
                ctx.fillStyle = gradient;
                ctx.shadowColor = 'rgba(0,0,0,0.2)';
                ctx.shadowBlur = 12;
                ctx.shadowOffsetY = 6;
                ctx.fill();
                ctx.shadowColor = 'transparent';

                ctx.strokeStyle = backdrop.detailColor;
                ctx.lineWidth = 2;
                const grooveCount = 5;
                for (let i = 1; i <= grooveCount; i++) {
                    const gy = drawY + (backdrop.height / (grooveCount + 1)) * i;
                    ctx.beginPath();
                    ctx.moveTo(drawX + 20, gy);
                    ctx.lineTo(drawX + backdrop.width - 20, gy);
                    ctx.stroke();
                }

                backdrop.holes.forEach(hole => {
                    ctx.fillStyle = 'rgba(0,0,0,0.18)';
                    ctx.beginPath();
                    ctx.ellipse(drawX + hole.x, drawY + hole.y, hole.rx, hole.ry, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.beginPath();
                    ctx.ellipse(drawX + hole.x - hole.rx * 0.2, drawY + hole.y - hole.ry * 0.35, hole.rx * 0.45, hole.ry * 0.45, 0, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();
            });
        }

        function drawHandcraftedCanopy(ctx, cameraX, canopySegments) {
            const parallax = 0.25;
            canopySegments.forEach(segment => {
                const drawX = segment.x - cameraX * parallax;
                const drawY = segment.y;
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(drawX, drawY + segment.height);
                ctx.lineTo(drawX, drawY + segment.arcHeight);
                ctx.quadraticCurveTo(drawX + segment.width / 2, drawY, drawX + segment.width, drawY + segment.arcHeight);
                ctx.lineTo(drawX + segment.width, drawY + segment.height);
                ctx.closePath();

                const canopyGradient = ctx.createLinearGradient(0, drawY, 0, drawY + segment.height);
                canopyGradient.addColorStop(0, '#5fcf6b');
                canopyGradient.addColorStop(1, '#2f8741');
                ctx.fillStyle = canopyGradient;
                ctx.shadowColor = 'rgba(0,0,0,0.25)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetY = 6;
                ctx.fill();
                ctx.shadowColor = 'transparent';

                ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(drawX + segment.width * 0.25, drawY + segment.arcHeight * 0.6, 12, Math.PI * 0.1, Math.PI * 1.2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(drawX + segment.width * 0.7, drawY + segment.arcHeight * 0.55, 9, Math.PI * 0.2, Math.PI * 1.3);
                ctx.stroke();

                ctx.restore();
            });
        }

        function drawStrataPlatform(ctx, platform, cameraX) {
            const drawX = platform.x - cameraX;
            ctx.save();
            traceRoundedRect(ctx, drawX, platform.y, platform.width, platform.height, 14);
            const fillGradient = ctx.createLinearGradient(0, platform.y, 0, platform.y + platform.height);
            platform.strataColors.forEach(stop => fillGradient.addColorStop(stop.offset, stop.color));
            ctx.fillStyle = fillGradient;
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 6;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 4;
            ctx.fill();
            ctx.shadowColor = 'transparent';

            if (platform.grooves > 0) {
                ctx.strokeStyle = platform.detailColor;
                ctx.lineWidth = 2;
                for (let i = 1; i <= platform.grooves; i++) {
                    const gy = platform.y + (platform.height / (platform.grooves + 1)) * i;
                    ctx.beginPath();
                    ctx.moveTo(drawX + 16, gy);
                    ctx.lineTo(drawX + platform.width - 16, gy);
                    ctx.stroke();
                }
            }

            if (platform.topHighlight) {
                ctx.globalAlpha = 0.6;
                const highlightHeight = platform.height * 0.22;
                traceRoundedRect(ctx, drawX + 2, platform.y - 4, platform.width - 4, highlightHeight, 10);
                ctx.fillStyle = platform.topHighlight;
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            platform.holes.forEach(hole => {
                ctx.fillStyle = 'rgba(0,0,0,0.22)';
                ctx.beginPath();
                ctx.ellipse(drawX + hole.x, platform.y + hole.y, hole.rx, hole.ry, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.22)';
                ctx.beginPath();
                ctx.ellipse(drawX + hole.x - hole.rx * 0.3, platform.y + hole.y - hole.ry * 0.4, hole.rx * 0.4, hole.ry * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        /**
         * Draws stars for the boss battle background with twinkling effect.
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context.
         * @param {number} frameCounter The current frame count for animation.
         */
        function drawStars(ctx, frameCounter) {
            stars.forEach(star => {
                // Twinkling effect using sine wave
                const twinkleFactor = Math.sin(frameCounter * 0.05 + star.initialAlpha * 10) * 0.5 + 0.5; // Oscillates between 0.5 and 1.0
                ctx.fillStyle = `rgba(255, 255, 255, ${star.initialAlpha * twinkleFactor})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        /**
         * Draws the hero using layered shapes inspired by the reference art.
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} x - Top-left draw X.
         * @param {number} y - Top-left draw Y.
         * @param {number} width - Bounding box width.
         * @param {number} height - Bounding box height.
         * @param {number} frameCounter - Global frame counter for subtle animation.
         */
        function drawSkirbyCharacter(ctx, x, y, width, height, frameCounter, pose = {}) {
            ctx.save();
            const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
            const cx = x + width / 2;
            const cy = y + height / 2;
            const bodyRadius = Math.min(width, height) * 0.5;
            const facing = pose.facing ?? 1;
            const move = clamp(pose.move ?? 0, -1, 1);
            const airborne = pose.airborne ?? false;
            const punching = pose.punching ?? false;
            const spinning = pose.spinning ?? false;
            const verticalMomentum = pose.dy ?? 0;

            const breathe = Math.sin(frameCounter * 0.05) * 0.015;
            const lean = move * 0.2 + (airborne ? -verticalMomentum * 0.018 : 0);

            ctx.translate(cx, cy + bodyRadius * 0.04 * Math.sin(frameCounter * 0.1));
            ctx.scale(1 + breathe, 1 - breathe);
            ctx.rotate(lean);

            const normalizedDy = clamp(verticalMomentum / 12, -1, 1);
            const ascendFactor = airborne ? clamp(-normalizedDy, 0, 1) : 0;
            const descendFactor = airborne ? clamp(normalizedDy, 0, 1) : 0;
            const airborneFactor = airborne ? 1 : 0;

            const stride = move * bodyRadius * (airborne ? 0.12 : 0.18);
            const groundStrideScalar = (1 - airborneFactor) * move;
            const jumpLift = airborne ? bodyRadius * (0.32 + ascendFactor * 0.28 - descendFactor * 0.18) : Math.abs(move) * bodyRadius * 0.04;
            const spinSpread = spinning ? bodyRadius * 0.45 : 0;

            const drawLimb = (offsetX, offsetY, radiusX, radiusY, rotation, fill, stroke) => {
                ctx.save();
                ctx.translate(offsetX, offsetY);
                if (rotation) ctx.rotate(rotation);
                ctx.beginPath();
                ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, Math.PI * 2);
                ctx.fillStyle = fill;
                ctx.fill();
                if (stroke) {
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.restore();
            };

            const footRadiusX = bodyRadius * 0.7;
            const footRadiusY = bodyRadius * 0.42;
            const armRadiusX = bodyRadius * 0.56;
            const armRadiusY = bodyRadius * 0.42;

            const rearFoot = {
                x: -facing * (bodyRadius * 0.48 - spinSpread * 0.15) + groundStrideScalar * bodyRadius * 0.1,
                y: bodyRadius * (0.96 + descendFactor * 0.1) - jumpLift * 0.2,
                rot: facing * (0.35 * ascendFactor - 0.25 * descendFactor) + move * 0.18 * (1 - airborneFactor)
            };
            drawLimb(rearFoot.x, rearFoot.y, footRadiusX, footRadiusY, rearFoot.rot, '#e63a57', '#b1243d');

            const rearArm = {
                x: -facing * (bodyRadius * 0.82 - spinSpread * 0.28) + groundStrideScalar * bodyRadius * 0.08,
                y: bodyRadius * (-0.06 - ascendFactor * 0.55 + descendFactor * 0.18) - jumpLift * 0.1,
                rot: facing * (0.68 * ascendFactor - 0.28 * descendFactor) + move * 0.24 * (1 - airborneFactor)
            };
            drawLimb(rearArm.x, rearArm.y, armRadiusX, armRadiusY, rearArm.rot, '#ff7aa2', '#d4527c');

            const frontFoot = {
                x: facing * (bodyRadius * 0.6 + spinSpread * 0.24) + groundStrideScalar * bodyRadius * 0.16 + ascendFactor * bodyRadius * 0.12,
                y: bodyRadius * (0.95 + descendFactor * 0.12) - jumpLift * 0.8,
                rot: facing * (-0.5 * ascendFactor + 0.3 * descendFactor) + move * -0.3 * (1 - airborneFactor)
            };

            const frontArmExtend = punching ? bodyRadius * 0.6 : 0;
            const frontArm = {
                x: facing * (bodyRadius * 0.94 + spinSpread * 0.36) + groundStrideScalar * bodyRadius * 0.12 + frontArmExtend,
                y: bodyRadius * (-0.12 - ascendFactor * 0.65 + descendFactor * 0.18 - (punching ? 0.22 : 0)) - jumpLift * 0.05,
                rot: punching ? facing * -1.0 : facing * (-0.85 * ascendFactor + 0.28 * descendFactor) + move * -0.26 * (1 - airborneFactor)
            };

            const bodyGradient = ctx.createRadialGradient(-facing * bodyRadius * 0.27, -bodyRadius * 0.38, bodyRadius * 0.18, 0, 0, bodyRadius);
            bodyGradient.addColorStop(0, '#ff9bd3');
            bodyGradient.addColorStop(1, '#ff4f95');
            ctx.fillStyle = bodyGradient;
            ctx.strokeStyle = '#d3407d';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, bodyRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            drawLimb(frontFoot.x, frontFoot.y, footRadiusX, footRadiusY, frontFoot.rot, '#ff4a6b', '#b1243d');
            drawLimb(frontArm.x, frontArm.y, armRadiusX, armRadiusY, frontArm.rot, '#ff7aa2', '#d4527c');

            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.ellipse(-facing * bodyRadius * 0.36, -bodyRadius * 0.44, bodyRadius * 0.32, bodyRadius * 0.24, -0.35 * facing, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(255, 120, 155, 0.7)';
            const blushRadius = bodyRadius * 0.21;
            const blushLift = bodyRadius * (0.08 - ascendFactor * 0.12 + descendFactor * 0.05);
            ctx.beginPath();
            ctx.ellipse(-bodyRadius * 0.45, blushLift, blushRadius, blushRadius * 0.54, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(bodyRadius * 0.45, blushLift, blushRadius, blushRadius * 0.54, 0, 0, Math.PI * 2);
            ctx.fill();

            const gazeOffset = facing * move * 0.1 * bodyRadius;
            const eyeSeparation = bodyRadius * 0.24;
            const eyeHeight = bodyRadius * (0.7 + descendFactor * 0.05 - ascendFactor * 0.12);
            const eyeWidth = bodyRadius * 0.24;
            const eyeVertical = -bodyRadius * 0.12 - ascendFactor * bodyRadius * 0.08 + descendFactor * bodyRadius * 0.04;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(-eyeSeparation + gazeOffset, eyeVertical, eyeWidth, eyeHeight, 0, 0, Math.PI * 2);
            ctx.ellipse(eyeSeparation + gazeOffset, eyeVertical, eyeWidth, eyeHeight, 0, 0, Math.PI * 2);
            ctx.fill();

            const pupilGradient = ctx.createLinearGradient(0, -eyeHeight, 0, eyeHeight);
            pupilGradient.addColorStop(0, '#194b7c');
            pupilGradient.addColorStop(0.55, '#102144');
            pupilGradient.addColorStop(1, '#070c1a');
            ctx.fillStyle = pupilGradient;
            ctx.beginPath();
            ctx.ellipse(-eyeSeparation * 0.86 + gazeOffset, eyeVertical + eyeHeight * 0.22, eyeWidth * 0.55, eyeHeight * 0.68, 0, 0, Math.PI * 2);
            ctx.ellipse(eyeSeparation * 0.86 + gazeOffset, eyeVertical + eyeHeight * 0.22, eyeWidth * 0.55, eyeHeight * 0.68, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.beginPath();
            ctx.ellipse(-eyeSeparation * 0.9 + gazeOffset, eyeVertical - eyeHeight * 0.42, eyeWidth * 0.28, eyeHeight * 0.26, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(eyeSeparation * 0.9 + gazeOffset, eyeVertical - eyeHeight * 0.42, eyeWidth * 0.28, eyeHeight * 0.26, 0, 0, Math.PI * 2);
            ctx.fill();

            const mouthOffsetX = gazeOffset * 0.35;
            const mouthY = bodyRadius * (0.14 - airborneFactor * 0.25);
            ctx.fillStyle = '#521530';
            ctx.beginPath();
            ctx.ellipse(mouthOffsetX, mouthY, bodyRadius * 0.09, bodyRadius * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(255, 198, 185, 0.85)';
            ctx.beginPath();
            ctx.ellipse(mouthOffsetX, mouthY - bodyRadius * 0.02, bodyRadius * 0.05, bodyRadius * 0.06, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // --- Boss Battle Logic ---

        /**
         * Initializes and starts the boss battle.
         */
        function startBossBattle() {
            console.log("Starting Boss Battle..."); // Debug log
            setGameState(GAME_STATE.BOSS_BATTLE);
            console.log("Game State set to BOSS_BATTLE."); // Debug log

            // Reset boss health and position
            boss.health = boss.maxHealth;
            boss.x = CANVAS_WIDTH / 2 - boss.width / 2;
            boss.y = 100;
            boss.dx = 2; // Reset boss speed
            boss.currentAttackCooldown = 0; // Reset cooldown
            boss.isAttacking = false;
            boss.bubbles = [];
            boss.isCharging = false;

            // Move player to a starting position for boss battle
            player.x = CANVAS_WIDTH / 2 - player.width / 2;
            player.y = CANVAS_HEIGHT - 100; // Player starts on the "ground" for boss battle
            player.dy = 0;
            player.onGround = false; // Will be set to true by ground collision in update
            player.isInvincible = false; // Reset invincibility for boss battle
            player.invincibilityTimer = 0; // Reset invincibility timer for boss battle
            player.knockbackX = 0; // Reset knockback for boss battle
            player.knockbackY = 0; // Reset knockback for boss battle
            cameraX = 0; // Camera is fixed for boss battle

            // Start the game loop if it's not running
            if (!gameLoopId) {
                startGameLoop();
            }
            console.log("Boss Battle setup complete. Player Health:", player.health); // Debug log
        }

        /**
         * Updates the boss's state, movement, and attacks.
         */
        function updateBossBattle() {
            // Boss horizontal movement (normal patrol)
            if (!boss.isCharging) {
                boss.x += boss.dx;
            }

            // Boss attack logic
            boss.currentAttackCooldown--;
            if (boss.currentAttackCooldown <= 0 && !boss.isAttacking) {
                // Randomly choose an attack
                const attackTypes = ['bubble', 'charge'];
                boss.attackType = attackTypes[Math.floor(Math.random() * attackTypes.length)];
                boss.isAttacking = true;
                boss.currentAttackCooldown = boss.attackCooldown; // Reset cooldown

                if (boss.attackType === 'bubble') {
                    // Spawn bubbles
                    for (let i = 0; i < 5; i++) {
                        boss.bubbles.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height,
                            radius: 15,
                            dy: Math.random() * 3 + 2, // Speed
                            dx: (Math.random() - 0.5) * 4, // Horizontal drift
                            color: 'rgba(173, 216, 230, 0.7)' // Light blue
                        });
                    }
                } else if (boss.attackType === 'charge') {
                    // Prepare for charge attack
                    boss.chargeTargetX = player.x;
                    boss.chargeTargetY = player.y;
                    boss.isCharging = true;
                }
            }

            // Update charge attack
            if (boss.isCharging) {
                const angle = Math.atan2(boss.chargeTargetY - (boss.y + boss.height / 2), boss.chargeTargetX - (boss.x + boss.width / 2));
                boss.x += Math.cos(angle) * (boss.speed * 3); // Faster charge
                boss.y += Math.sin(angle) * (boss.speed * 3);

                // Stop charging if close to target or hit player
                if (Math.abs(boss.x - boss.chargeTargetX) < 20 && Math.abs(boss.y - boss.chargeTargetY) < 20) {
                    boss.isCharging = false;
                    boss.isAttacking = false;
                }
                // Collision with player during charge
                if (checkCollision(player, boss) && !player.isInvincible) { // Only take damage if not invincible
                    player.health -= 10;
                    updateUI();
                    boss.isCharging = false;
                    boss.isAttacking = false;
                    // Apply knockback to player
                    player.knockbackX = (player.x > boss.x ? 1 : -1) * 10;
                    player.knockbackY = -10;
                    player.isInvincible = true;
                    player.invincibilityTimer = player.invincibilityDuration;

                    // Knock back boss slightly
                    boss.dx *= -1;
                    boss.dy = -10; // Bounce up
                }
            } else {
                 boss.isAttacking = false; // Reset attack state after charge
            }

            // Clamp boss within horizontal bounds AFTER all movements
            if (boss.x < 0) {
                boss.x = 0;
                boss.dx = Math.abs(boss.dx); // Ensure it moves right
            } else if (boss.x + boss.width > CANVAS_WIDTH) {
                boss.x = CANVAS_WIDTH - boss.width;
                boss.dx = -Math.abs(boss.dx); // Ensure it moves left
            }

            // Clamp boss within vertical bounds (important if it moves vertically during charge)
            // The boss is flying, so it doesn't have gravity. Its y is only affected by charge/knockback.
            if (boss.y < 0) {
                boss.y = 0;
                // If boss was moving upwards and hit top, reverse its dy
                if (boss.dy < 0) boss.dy *= -1;
            } else if (boss.y + boss.height > CANVAS_HEIGHT) {
                boss.y = CANVAS_HEIGHT - boss.height;
                // If boss was moving downwards and hit bottom, reverse its dy
                if (boss.dy > 0) boss.dy *= -1;
            }

            // Update bubble movement
            boss.bubbles.forEach((bubble, index) => {
                bubble.y += bubble.dy;
                bubble.x += bubble.dx;
                // Remove bubbles that go off screen
                if (bubble.y > CANVAS_HEIGHT) {
                    boss.bubbles.splice(index, 1);
                }
                // Collision with player
                if (checkCollision(player, { x: bubble.x - bubble.radius, y: bubble.y - bubble.radius, width: bubble.radius * 2, height: bubble.radius * 2 }) && !player.isInvincible) {
                    player.health -= 5;
                    updateUI();
                    boss.bubbles.splice(index, 1); // Remove bubble on hit
                    player.knockbackX = (player.x > bubble.x ? 1 : -1) * 5;
                    player.knockbackY = -5;
                    player.isInvincible = true;
                    player.invincibilityTimer = player.invincibilityDuration;
                }
            });

            // Player attack on boss
            if (keys['f'] && player.isPunching && checkCollision(player, boss)) {
                boss.health -= 5; // Adjust damage
                console.log('Boss hit! Health:', boss.health);
                if (boss.health <= 0) {
                    // Boss defeated!
                    // Use a custom message box instead of alert()
                    displayMessageBox('Congratulations!', 'You defeated the Soap Boss!');
                    // alert('Congratulations! You defeated the Soap Boss!');
                    setGameState(GAME_STATE.INTRO); // Go back to intro or a victory screen
                    resetGame();
                }
            }
            if (keys['e'] && player.isSpinning && checkCollision(player, boss)) {
                boss.health -= 2; // Adjust damage
                console.log('Boss hit by Spin! Health:', boss.health);
                if (boss.health <= 0) {
                    // Use a custom message box instead of alert()
                    displayMessageBox('Congratulations!', 'You defeated the Soap Boss!');
                    // alert('Congratulations! Youhe Soap Boss!');
                    setGameState(GAME_STATE.INTRO);
                    resetGame();
                }
            }
        }

        /**
         * Draws a rounded rectangle using the current state of the canvas.
         * If "radius" is a single number, then it is used as the radius for all 4 corners.
         * If "radius" is an array, it specifies the radii for top-left, top-right, bottom-right, bottom-left corners.
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context.
         * @param {number} x The top-left x coordinate.
         * @param {number} y The top-left y coordinate.
         * @param {number} width The width of the rectangle.
         * @param {number} height The height of the rectangle.
         * @param {number|Array<number>} radius The corner radius.
         */
        function roundRect(ctx, x, y, width, height, radius) {
            if (typeof radius === 'number') {
                radius = {tl: radius, tr: radius, br: radius, radius, bl: radius};
            } else {
                radius = {tl: radius[0] || 0, tr: radius[1] || 0, br: radius[2] || 0, bl: radius[3] || 0};
            }
            ctx.beginPath();
            ctx.moveTo(x + radius.tl, y);
            ctx.lineTo(x + width - radius.tr, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
            ctx.lineTo(x + width, y + height - radius.br);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
            ctx.lineTo(x + radius.bl, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
            ctx.lineTo(x, y + radius.tl);
            ctx.quadraticCurveTo(x, y, x + radius.tl, y);
            ctx.closePath();
        }

        /**
         * Draws boss and boss-related elements.
         */
        function drawBossBattle() {
            // Draw boss (Soap with a mustache)
            // Create a linear gradient for the soap body to give it depth
            const gradient = ctx.createLinearGradient(boss.x, boss.y, boss.x + boss.width, boss.y + boss.height);
            gradient.addColorStop(0, '#F0F8FF'); // AliceBlue (lighter top-left)
            gradient.addColorStop(1, '#ADD8E6'); // LightBlue (darker bottom-right)
            ctx.fillStyle = gradient;

            // Draw rounded rectangle for the soap body
            const cornerRadius = 20; // Increased radius for more rounded look
            roundRect(ctx, boss.x, boss.y, boss.width, boss.height, cornerRadius);
            ctx.fill();

            // Add a subtle highlight for a "wet" or "foamy" effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // White with transparency
            ctx.beginPath();
            ctx.ellipse(boss.x + boss.width * 0.5, boss.y + boss.height * 0.2, boss.width * 0.4, boss.height * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            // Stroke the rounded rectangle
            roundRect(ctx, boss.x, boss.y, boss.width, boss.height, cornerRadius);
            ctx.stroke();

            // Draw mustache as a single, unified shape
            ctx.fillStyle = boss.mustacheColor;
            ctx.strokeStyle = boss.mustacheColor;
            ctx.lineWidth = 2;

            ctx.beginPath();
            // Start from the left tip of the mustache
            ctx.moveTo(boss.x + boss.width * 0.15, boss.y + boss.height * 0.65);
            // Curve upwards and inwards for the left side
            ctx.bezierCurveTo(
                boss.x + boss.width * 0.25, boss.y + boss.height * 0.55,
                boss.x + boss.width * 0.35, boss.y + boss.height * 0.55,
                boss.x + boss.width * 0.5, boss.y + boss.height * 0.6 // Peak of the upper lip
            );
            // Curve downwards and outwards for the right side
            ctx.bezierCurveTo(
                boss.x + boss.width * 0.65, boss.y + boss.height * 0.55,
                boss.x + boss.width * 0.75, boss.y + boss.height * 0.55,
                boss.x + boss.width * 0.85, boss.y + boss.height * 0.65 // Right tip of the mustache
            );
            // Now draw the bottom curve to close the shape
            ctx.bezierCurveTo(
                boss.x + boss.width * 0.7, boss.y + boss.height * 0.78, // Control point for right bottom curve
                boss.x + boss.width * 0.3, boss.y + boss.height * 0.78, // Control point for left bottom curve
                boss.x + boss.width * 0.15, boss.y + boss.height * 0.65 // Back to the starting point
            );
            ctx.closePath();
            ctx.fill();
            ctx.stroke();


            // Draw eyes with pupils and highlights
            ctx.fillStyle = boss.eyeColor;
            // Left eye white
            ctx.beginPath();
            ctx.arc(boss.x + boss.width * 0.35, boss.y + boss.height * 0.4, 10, 0, Math.PI * 2);
            ctx.fill();
            // Right eye white
            ctx.beginPath();
            ctx.arc(boss.x + boss.width * 0.65, boss.y + boss.height * 0.4, 10, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(boss.x + boss.width * 0.35, boss.y + boss.height * 0.4, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(boss.x + boss.width * 0.65, boss.y + boss.height * 0.4, 4, 0, Math.PI * 2);
            ctx.fill();

            // Eye highlights
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(boss.x + boss.width * 0.35 + 3, boss.y + boss.height * 0.4 - 3, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(boss.x + boss.width * 0.65 + 3, boss.y + boss.height * 0.4 - 3, 2, 0, Math.PI * 2);
            ctx.fill();


            // Draw boss health bar
            ctx.fillStyle = 'red';
            ctx.fillRect(boss.x, boss.y - 20, boss.width, 10);
            ctx.fillStyle = 'green';
            ctx.fillRect(boss.x, boss.y - 20, boss.width * (boss.health / boss.maxHealth), 10);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(boss.x, boss.y - 20, boss.width, 10);

            // Draw boss bubbles
            boss.bubbles.forEach(bubble => {
                ctx.fillStyle = bubble.color;
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 1;
                ctx.stroke();
                // Add a subtle highlight to the bubble
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(bubble.x - bubble.radius * 0.3, bubble.y - bubble.radius * 0.3, bubble.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        /**
         * Displays a custom message box instead of alert().
         * @param {string} title - The title of the message.
         * @param {string} message - The message content.
         */
        function displayMessageBox(title, message) {
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: rgba(0, 0, 0, 0.8);
                padding: 30px;
                border-radius: 20px;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
                color: white;
                text-align: center;
                z-index: 200;
                font-size: 1.5rem;
                max-width: 80%;
                border: 5px solid #FFD700;
            `;
            messageBox.innerHTML = `
                <h3 class="text-4xl font-bold mb-4 text-yellow-300">${title}</h3>
                <p class="mb-8">${message}</p>
                <button class="button-primary" id="messageBoxOk">OK</button>
            `;
            gameContainer.appendChild(messageBox);

            document.getElementById('messageBoxOk').addEventListener('click', () => {
                gameContainer.removeChild(messageBox);
            });
        }


        // Initialize sounds when the script loads
        setupSounds();

        // Set initial state
        setGameState(GAME_STATE.INTRO);

        // Ensure canvas resizes with window (though game logic uses fixed CANVAS_WIDTH/HEIGHT)
        window.addEventListener('resize', () => {
            // If you want a truly responsive game, you'd need to scale all game elements
            // For simplicity, we'll keep the canvas fixed size and let CSS handle container scaling.
            // However, for a better user experience, the game should adapt.
            // For now, we just ensure the game container itself resizes.
        });
    </script>
</body>
</html>
